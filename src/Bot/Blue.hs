-- Assignment completed by
-- Name    :Chucheng Qian
-- UID     :u6451847
-- Tutor   :David O'Donohue
-- Lab Time: 15:00 Monday

module Bot.Blue where
    
import Data.Board

import Data.Player


import Data.Cell


-- | ConnectX
--
-- >>> heuristic Board { board = [[Blue,Red,Empty,Empty],[Blue,Red,Empty,Empty],[Blue,Blue,Red,Empty],[Red,Red,Blue,Empty],[Red,Blue,Red,Empty]] ,blueScore = 6, redScore = 3,turn = BlueBot, dimension = (5, 4), connect = 4} BlueBot
-- 3
--
-- >>> findIndex Board { board = [[Blue,Red],[Blue,Red],[Blue,Blue,Red],[Red,Red,Blue],[Red,Blue,Red]] ,blueScore = 6, redScore = 3,turn = BlueBot, dimension = (5, 4), connect = 4} 1 0
-- [(1,0),(2,0),(3,12),(4,12),(5,56)]
--
-- >>> findMax [(1,0),(2,0),(3,12),(4,88),(5,56)]
-- 4
--
-- >>> scoreList 1 BlueBot 0 (-1000,1000) Board { board = [[Blue,Red],[Blue,Red],[Blue,Blue,Red],[Red,Red,Blue],[Red,Blue,Red]] ,blueScore = 6, redScore = 3,turn = BlueBot, dimension = (5, 4), connect = 4}
-- 24
--
-- >>> makeMove Board { board = [[Blue,Red],[Blue,Red],[Blue,Blue,Red],[Red,Red,Blue],[Red,Blue,Red]] ,blueScore = 6, redScore = 3,turn = BlueBot, dimension = (5, 4), connect = 4} 1
-- 5


makeMove :: Board -> LookAhead -> Int
makeMove b i = case concat (board b) of
               []   -> (div (getWidth b) 2) + 1
               _:_  -> findMax (findIndex b i 0)

type Alpha = Int
type Beta  = Int
type Pair  = (Int, Score)



--find the list of possible pairs of an index and a score.
findIndex :: Board -> LookAhead -> Int -> [Pair]
findIndex b i a = zip movelist scorelist
    where
        movelist = filter (validMove b) [1..(getWidth b)]
        scorelist = map (scoreList i (turn b) a (-100000, 100000)) (nextBoards b)

--evaluate the situstion of current board
heuristic ::  Board -> Player -> Score
heuristic    b p = case p of
             BlueBot -> (blueScore b) - (redScore b)
             RedBot  -> (redScore b ) - (blueScore b)
             Finished -> 0

--evaluate the possible score of current node by alpha-beta pruning and minimaxi
scoreList :: LookAhead -> Player -> Int -> (Alpha,Beta) -> Board -> Score
scoreList   i mp a (alpha,beta) b = case (a==i || (nextBoards b) == []) of
            True        -> heuristic b mp
            False
                | mp == (turn b)  -> maximise (nextBoards b) (alpha, beta)
                | otherwise       -> minimise (nextBoards b) (alpha, beta)

        where
            --find the maximum score among boards generated by current board
            maximise:: [Board] -> (Alpha,Beta)-> Score
            maximise boards (alpha1,beta1) = case boards of
                     [] -> alpha1
                     x:xs
                         |  alpha1 >= beta1     -> beta1
                         |  (scoreList i mp (a+1) (alpha1,beta1) x) >= beta1 -> beta1
                         |  (scoreList i mp (a+1) (alpha1,beta1) x) > alpha1 -> maximise xs ((scoreList i mp (a+1) (alpha1,beta1) x),beta1)
                         |  otherwise -> maximise xs (alpha1,beta1)

            --find the mainimum score among boards generated by current board
            minimise:: [Board] -> (Alpha,Beta)-> Score
            minimise boards (alpha2,beta2) = case boards of
                     [] -> beta2
                     x:xs
                         |  alpha2 >= beta2    -> alpha2
                         | (scoreList i mp (a+1) (alpha2,beta2) x) <= alpha2 -> alpha2
                         | (scoreList i mp (a+1) (alpha2,beta2) x) <= beta2 -> minimise xs (alpha2,(scoreList i mp (a+1) (alpha2,beta2) x))
                         | otherwise -> minimise xs (alpha2,beta2)

--find a list boards that each of them are add one possible moves respectively
nextBoards :: Board -> [Board]
nextBoards b = map (updateBoard b) (filter (validMove b) [1..width])
    where
        width = getWidth b


--get the width of the board
getWidth :: Board -> Int
getWidth    b = fst $ dimension b

--find the maximum score the blue will own and find its index
findMax :: [Pair] -> Int
findMax list = fst(foldr maxPair (0, -100000) list)
    where
        maxPair :: Pair -> Pair -> Pair
        maxPair (a1, s1) (a2, s2)
            | s1 >= s2 = (a1, s1)
            | otherwise = (a2, s2)


